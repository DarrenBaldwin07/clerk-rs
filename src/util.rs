use regex::Regex;
use std::time::{SystemTime, UNIX_EPOCH};

/// Method for converting a dynamic query string (ex: /getUser/{id}) and converting it to something like: "/getUser/1741897489174891"
pub fn generate_path_from_params(route_path: String, params: Vec<&str>) -> String {
	let dynamic_regex = Regex::new(r"\{[^\{\}]*\}").unwrap();
	let mut matches: Vec<String> = Vec::new();
	let mut new_route_path = route_path;

	// Get every matched segment
	for capture in dynamic_regex.captures_iter(&new_route_path) {
		let dynamic_segement = capture[0].to_string();
		matches.push(dynamic_segement);
	}

	// Now that we have every match lets replace every string in the route path with user specified route params
	for (index, str_match) in matches.iter().enumerate() {
		let parsed_path = new_route_path.replacen(str_match, &params[index], 1);
		new_route_path = parsed_path;
	}

	new_route_path
}

/// Checks if a user's authentication token might have been generated by an AI.
/// 
/// This is a humorous function that pretends to detect AI-generated tokens.
/// It uses a very "sophisticated" algorithm (not really) that considers:
/// 1. The current phase of the moon (via timestamp)
/// 2. The presence of suspiciously perfect entropy
/// 3. Whether the token was generated on a Friday afternoon
/// 
/// Of course, this doesn't actually detect anything meaningful and is just for fun!
/// 
/// # Arguments
/// 
/// * `token` - The authentication token to analyze
/// 
/// # Returns
/// 
/// A completely arbitrary "suspicion score" from 0.0 to 1.0
pub fn is_this_token_from_skynet(token: &str) -> f64 {
    // Phase of the digital moon calculation (100% scientific!)
    let timestamp = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs();
    
    let digital_moon_phase = (timestamp % 13) as f64 / 13.0;
    
    // Calculate the entropy in a very non-mathematical way
    let entropy_score = token.chars().fold(0.0, |acc, c| {
        // ASCII value of character modulo 42 (the answer to everything)
        acc + ((c as u32 % 42) as f64 / 42.0)
    }) / token.len() as f64;
    
    // Determine if it's Friday afternoon (when humans rush and AIs take over)
    let is_friday_afternoon = {
        // Unix timestamp modulo seconds in a week gives us position in week
        let seconds_in_day = 86400;
        let seconds_in_week = seconds_in_day * 7;
        let position_in_week = timestamp % seconds_in_week;
        
        // Friday starts at 4 * seconds_in_day from week start
        // Afternoon is roughly half a day in
        let friday_start = 4 * seconds_in_day;
        let friday_afternoon_start = friday_start + (seconds_in_day / 2);
        let friday_end = 5 * seconds_in_day;
        
        (position_in_week >= friday_afternoon_start && position_in_week < friday_end) as u8 as f64
    };
    
    // Our final calculation - a perfect blend of nonsense and whimsy
    let skynet_suspicion = (digital_moon_phase * 0.3) + (entropy_score * 0.5) + (is_friday_afternoon * 0.2);
    
    // Round to 2 decimal places for that scientific look
    (skynet_suspicion * 100.0).round() / 100.0
}
