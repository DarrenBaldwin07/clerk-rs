/*
 * Clerk Backend API
 *
 * The Clerk REST Backend API, meant to be accessed by backend servers. Please see https://clerk.com/docs for more information.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@clerk.com
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};


/// struct for typed errors of method [`create_o_auth_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateOAuthApplicationError {
    Status400(crate::models::ClerkErrors),
    Status403(crate::models::ClerkErrors),
    Status422(crate::models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_o_auth_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteOAuthApplicationError {
    Status403(crate::models::ClerkErrors),
    Status404(crate::models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_o_auth_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetOAuthApplicationError {
    Status403(crate::models::ClerkErrors),
    Status404(crate::models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_o_auth_applications`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListOAuthApplicationsError {
    Status400(crate::models::ClerkErrors),
    Status403(crate::models::ClerkErrors),
    Status422(crate::models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`rotate_o_auth_application_secret`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RotateOAuthApplicationSecretError {
    Status403(crate::models::ClerkErrors),
    Status404(crate::models::ClerkErrors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_o_auth_application`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateOAuthApplicationError {
    Status403(crate::models::ClerkErrors),
    Status404(crate::models::ClerkErrors),
    Status422(crate::models::ClerkErrors),
    UnknownValue(serde_json::Value),
}


/// Creates a new OAuth application with the given name and callback URL for an instance. The callback URL must be a valid url. All URL schemes are allowed such as `http://`, `https://`, `myapp://`, etc...
pub async fn create_o_auth_application(configuration: &configuration::Configuration, create_o_auth_application_request: Option<crate::models::CreateOAuthApplicationRequest>) -> Result<crate::models::OAuthApplicationWithSecret, Error<CreateOAuthApplicationError>> {
    // Validate the request if it exists
    if let Some(request) = &create_o_auth_application_request {
        if let Err(validation_error) = request.validate() {
            // Convert validation error to a ClerkError
            let clerk_error = crate::models::ClerkError::new(
                validation_error.clone(),
                validation_error.clone(),
                "invalid_parameters".to_string()
            );
                
            let clerk_errors = crate::models::ClerkErrors {
                errors: vec![clerk_error],
            };
            
            let content = serde_json::to_string(&clerk_errors).unwrap_or_else(|_| String::from("{{\"errors\":[{\"message\":\"Validation error\"}]}}"));
            
            return Err(Error::ResponseError(ResponseContent {
                status: reqwest::StatusCode::UNPROCESSABLE_ENTITY,
                content,
                entity: Some(CreateOAuthApplicationError::Status422(clerk_errors)),
            }));
        }
    }
    
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth_applications", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&create_o_auth_application_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateOAuthApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes the given OAuth application. This is not reversible.
pub async fn delete_o_auth_application(configuration: &configuration::Configuration, oauth_application_id: &str) -> Result<crate::models::DeletedObject, Error<DeleteOAuthApplicationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth_applications/{oauth_application_id}", local_var_configuration.base_path, oauth_application_id=crate::apis::urlencode(oauth_application_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DeleteOAuthApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Fetches the OAuth application whose ID matches the provided `id` in the path.
pub async fn get_o_auth_application(configuration: &configuration::Configuration, oauth_application_id: &str) -> Result<crate::models::OAuthApplication, Error<GetOAuthApplicationError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth_applications/{oauth_application_id}", local_var_configuration.base_path, oauth_application_id=crate::apis::urlencode(oauth_application_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetOAuthApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// This request returns the list of OAuth applications for an instance. Results can be paginated using the optional `limit` and `offset` query parameters. The OAuth applications are ordered by descending creation date. Most recent OAuth applications will be returned first.
pub async fn list_o_auth_applications(configuration: &configuration::Configuration, limit: Option<f32>, offset: Option<f32>) -> Result<crate::models::OAuthApplications, Error<ListOAuthApplicationsError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth_applications", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_str) = limit {
        local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_str) = offset {
        local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
    }
    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<ListOAuthApplicationsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Rotates the OAuth application's client secret. When the client secret is rotated, make sure to update it in authorized OAuth clients.
pub async fn rotate_o_auth_application_secret(configuration: &configuration::Configuration, oauth_application_id: &str) -> Result<crate::models::OAuthApplicationWithSecret, Error<RotateOAuthApplicationSecretError>> {
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth_applications/{oauth_application_id}/rotate_secret", local_var_configuration.base_path, oauth_application_id=crate::apis::urlencode(oauth_application_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<RotateOAuthApplicationSecretError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Updates an existing OAuth application
pub async fn update_o_auth_application(configuration: &configuration::Configuration, oauth_application_id: &str, update_o_auth_application_request: crate::models::UpdateOAuthApplicationRequest) -> Result<crate::models::OAuthApplication, Error<UpdateOAuthApplicationError>> {
    // Validate the request first
    if let Err(validation_error) = update_o_auth_application_request.validate() {
        // Convert validation error to a ClerkError
        let clerk_error = crate::models::ClerkError::new(
            validation_error.clone(),
            validation_error.clone(),
            "invalid_parameters".to_string()
        );
            
        let clerk_errors = crate::models::ClerkErrors {
            errors: vec![clerk_error],
        };
        
        let content = serde_json::to_string(&clerk_errors).unwrap_or_else(|_| String::from("{{\"errors\":[{\"message\":\"Validation error\"}]}}"));
        
        return Err(Error::ResponseError(ResponseContent {
            status: reqwest::StatusCode::UNPROCESSABLE_ENTITY,
            content,
            entity: Some(UpdateOAuthApplicationError::Status422(clerk_errors)),
        }));
    }
    
    let local_var_configuration = configuration;

    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/oauth_applications/{oauth_application_id}", local_var_configuration.base_path, oauth_application_id=crate::apis::urlencode(oauth_application_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    if let Some(ref local_var_token) = local_var_configuration.bearer_access_token {
        local_var_req_builder = local_var_req_builder.bearer_auth(local_var_token.to_owned());
    };
    local_var_req_builder = local_var_req_builder.json(&update_o_auth_application_request);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<UpdateOAuthApplicationError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

