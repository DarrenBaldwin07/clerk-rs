/*
 * Clerk Backend API
 *
 * The Clerk REST Backend API, meant to be accessed by backend servers. Please see https://clerk.com/docs for more information.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@clerk.com
 * Generated by: https://openapi-generator.tech
 */

use url::Url;
use regex::Regex;
use std::collections::HashSet;

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct UpdateOAuthApplicationRequest {
	/// The new name of the OAuth application
	#[serde(rename = "name", skip_serializing_if = "Option::is_none")]
	pub name: Option<String>,
	/// The new callback URL of the OAuth application
	#[serde(rename = "callback_url", skip_serializing_if = "Option::is_none")]
	pub callback_url: Option<String>,
	/// Define the allowed scopes for the new OAuth applications that dictate the user payload of the OAuth user info endpoint. Available scopes are `profile`, `email`, `public_metadata`, `private_metadata`. Provide the requested scopes as a string, separated by spaces.
	#[serde(rename = "scopes", skip_serializing_if = "Option::is_none")]
	pub scopes: Option<String>,
}

impl UpdateOAuthApplicationRequest {
	pub fn new() -> UpdateOAuthApplicationRequest {
		UpdateOAuthApplicationRequest {
			name: None,
			callback_url: None,
			scopes: None,
		}
	}
	
	/// Validates the fields of the update request
	pub fn validate(&self) -> Result<(), String> {
		// Validate name if present
		if let Some(name) = &self.name {
			if name.is_empty() {
				return Err("OAuth application name cannot be empty".to_string());
			}
			
			if name.len() > 100 {
				return Err("OAuth application name cannot exceed 100 characters".to_string());
			}
		}
		
		// Validate callback_url if present
		if let Some(callback_url) = &self.callback_url {
			if callback_url.is_empty() {
				return Err("Callback URL cannot be empty".to_string());
			}
			
			// Validate URL format
			match Url::parse(callback_url) {
				Ok(_) => {},
				Err(_) => return Err("Invalid callback URL format".to_string()),
			}
		}
		
		// Validate scopes if present
		if let Some(scopes) = &self.scopes {
			if scopes.is_empty() {
				return Err("Scopes cannot be empty".to_string());
			}
			
			// Define the allowed scopes
			let allowed_scopes: HashSet<&str> = vec!["profile", "email", "public_metadata", "private_metadata"]
				.into_iter()
				.collect();
			
			// Check that all provided scopes are in the allowed set
			for scope in scopes.split_whitespace() {
				if !allowed_scopes.contains(scope) {
					return Err(format!("Invalid scope: {}", scope));
				}
			}
		}
		
		Ok(())
	}
}
