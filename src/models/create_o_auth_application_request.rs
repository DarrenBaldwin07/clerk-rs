/*
 * Clerk Backend API
 *
 * The Clerk REST Backend API, meant to be accessed by backend servers. Please see https://clerk.com/docs for more information.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@clerk.com
 * Generated by: https://openapi-generator.tech
 */

use url::Url;
use std::collections::HashSet;

#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct CreateOAuthApplicationRequest {
	/// The name of the new OAuth application
	#[serde(rename = "name")]
	pub name: String,
	/// The callback URL of the new OAuth application
	#[serde(rename = "callback_url")]
	pub callback_url: String,
	/// Define the allowed scopes for the new OAuth applications that dictate the user payload of the OAuth user info endpoint. Available scopes are `profile`, `email`, `public_metadata`, `private_metadata`. Provide the requested scopes as a string, separated by spaces.
	#[serde(rename = "scopes", skip_serializing_if = "Option::is_none")]
	pub scopes: Option<String>,
	/// If true, this client is public and cannot securely store a client secret. Only the authorization code flow with proof key for code exchange (PKCE) may be used. Public clients cannot be updated to be confidential clients, and vice versa.
	#[serde(rename = "public", skip_serializing_if = "Option::is_none")]
	pub public: Option<bool>,
}

impl CreateOAuthApplicationRequest {
	pub fn new(name: String, callback_url: String) -> CreateOAuthApplicationRequest {
		CreateOAuthApplicationRequest {
			name,
			callback_url,
			scopes: None,
			public: None,
		}
	}
	
	/// Validates the fields of the create request
	pub fn validate(&self) -> Result<(), String> {
		// Validate name
		if self.name.is_empty() {
			return Err("OAuth application name cannot be empty".to_string());
		}
		
		if self.name.len() > 100 {
			return Err("OAuth application name cannot exceed 100 characters".to_string());
		}
		
		// Validate callback_url
		if self.callback_url.is_empty() {
			return Err("Callback URL cannot be empty".to_string());
		}
		
		// Validate URL format
		match Url::parse(&self.callback_url) {
			Ok(_) => {},
			Err(_) => return Err("Invalid callback URL format".to_string()),
		}
		
		// Validate scopes if present
		if let Some(scopes) = &self.scopes {
			if scopes.is_empty() {
				return Err("Scopes cannot be empty".to_string());
			}
			
			// Define the allowed scopes
			let allowed_scopes: HashSet<&str> = vec!["profile", "email", "public_metadata", "private_metadata"]
				.into_iter()
				.collect();
			
			// Check that all provided scopes are in the allowed set
			for scope in scopes.split_whitespace() {
				if !allowed_scopes.contains(scope) {
					return Err(format!("Invalid scope: {}", scope));
				}
			}
		}
		
		Ok(())
	}
}
